{% extends "base.html" %}

{% block title %}Exam Interface{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <!-- Exam Header -->
        <div class="col-12">
            <div class="card mb-3">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h4 class="mb-0">{{ exam.title }}</h4>
                    <div>
                        <span class="badge bg-primary me-2" id="timer">Time Remaining: --:--</span>
                        <button class="btn btn-danger" id="endExamBtn">End Exam</button>
                    </div>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-6">
                            <strong>Duration:</strong> {{ exam.duration }} minutes<br>
                            <strong>Total Marks:</strong> {{ exam.total_marks }}
                        </div>
                        <div class="col-md-6 text-end">
                            <strong>Started:</strong> <span id="startTime">--</span><br>
                            <strong>Ends:</strong> <span id="examEndTime" data-utc="{{ exam.end_time.isoformat() }}"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="col-md-8">
            <!-- Question Paper -->
            <div class="card mb-3">
                <div class="card-header">
                    <h5 class="mb-0">Question Paper</h5>
                </div>
                <div class="card-body">
                    <div id="questionPaper" style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; padding: 15px; background-color: #f9f9f9;">
                        <div class="text-center text-muted">
                            <i class="fas fa-spinner fa-spin"></i> Loading question paper...
                        </div>
                    </div>
                </div>
            </div>

            <!-- Answer Section -->
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">Your Answer</h5>
                </div>
                <div class="card-body">
                    <div class="mb-3">
                        <label for="answerText" class="form-label">Write your answer below:</label>
                        <textarea class="form-control" id="answerText" rows="10" placeholder="Type your answer here..."></textarea>
                    </div>
                    <!-- New: File upload for answer script -->
                    <div class="mb-3">
                        <label for="answerFile" class="form-label">Or upload your answer script (PDF, Word, or Text):</label>
                        <input type="file" class="form-control" id="answerFile" accept=".pdf,.doc,.docx,.txt">
                        <button class="btn btn-info mt-2" id="uploadAnswerBtn">Upload Answer Script</button>
                        <div id="fileUploadStatus" class="mt-2"></div>
                    </div>
                    <div id="uploadedFilesList" class="mt-3"></div>
                    <div class="d-flex justify-content-between">
                        <button class="btn btn-primary" id="saveAnswerBtn">Save Answer</button>
                        <button class="btn btn-success" id="submitAnswerBtn">Submit Answer</button>
                    </div>
                    <div id="answerStatus" class="mt-3"></div>
                </div>
            </div>
        </div>

        <!-- Proctoring Panel -->
        <div class="col-md-4">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">Proctoring Status</h5>
                </div>
                <div class="card-body">
                    <div class="text-center mb-3">
                        <video id="proctoringVideo" width="320" height="240" autoplay playsinline style="border:1px solid #ccc;"></video>
                        <canvas id="proctoringCanvas" width="320" height="240" style="display:none;"></canvas>
                    </div>
                    
                    <div class="proctoring-status">
                        <div class="mb-2">
                            <strong>Faces Detected:</strong> <span id="proctoringFaces">-</span>
                        </div>
                        <div class="mb-2">
                            <strong>Head Pose:</strong> <span id="proctoringHeadPose">-</span>
                        </div>
                        <div class="mb-2">
                            <strong>Left Eye:</strong> <span id="proctoringLeftEye">-</span>
                        </div>
                        <div class="mb-2">
                            <strong>Right Eye:</strong> <span id="proctoringRightEye">-</span>
                        </div>
                    </div>
                    
                    <div class="mt-3">
                        <div class="d-flex">
                            <div class="me-2 text-center">
                                <div style="font-size:0.8em;">Left Eye</div>
                                <img id="proctoringLeftEyeImg" src="" width="60" height="36" style="border:1px solid #ccc;object-fit:cover;"/>
                            </div>
                            <div class="text-center">
                                <div style="font-size:0.8em;">Right Eye</div>
                                <img id="proctoringRightEyeImg" src="" width="60" height="36" style="border:1px solid #ccc;object-fit:cover;"/>
                            </div>
                        </div>
                    </div>
                    
                    <div id="proctoringAlerts" class="mt-3"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- End Exam Confirmation Modal -->
<div class="modal fade" id="endExamModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">End Exam</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to end this exam? This action cannot be undone.</p>
                <p><strong>Note:</strong> Your answers will be saved automatically.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirmEndExamBtn">End Exam</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function() {
  let examId = Number('{{ exam.id }}');
  let examDuration = Number('{{ exam.duration }}'); // in minutes
  let globalExamEndTime = new Date('{{ exam.end_time.isoformat() }}');
  let examEndTime = null;
  let sessionId = null;
  let proctoringStream = null;
  let proctoringInterval = null;
  let timerInterval = null;
  let examStartTime = null;

  // Hide End Exam button until exam is initialized
  const endExamBtn = document.getElementById('endExamBtn');
  if (endExamBtn) endExamBtn.style.display = 'none';

  // Automatically start the exam session after redirect from verification
  initializeExam();

  // DOM elements
  const timerElement = document.getElementById('timer');
  const startTimeElement = document.getElementById('startTime');
  const questionPaperElement = document.getElementById('questionPaper');
  const answerTextElement = document.getElementById('answerText');
  const saveAnswerBtn = document.getElementById('saveAnswerBtn');
  const submitAnswerBtn = document.getElementById('submitAnswerBtn');
  const answerStatusElement = document.getElementById('answerStatus');
  const proctoringVideo = document.getElementById('proctoringVideo');
  const proctoringCanvas = document.getElementById('proctoringCanvas');

  // File upload logic for answer script
  const answerFileInput = document.getElementById('answerFile');
  const uploadAnswerBtn = document.getElementById('uploadAnswerBtn');
  const fileUploadStatus = document.getElementById('fileUploadStatus');
  const uploadedFilesList = document.getElementById('uploadedFilesList');

  async function loadUploadedFiles() {
    try {
      const response = await fetch(`/api/exam/${examId}/my-answers`);
      const data = await response.json();
      if (data.files && data.files.length > 0) {
        uploadedFilesList.innerHTML = '<b>Your Uploaded Answer Scripts:</b><ul class="list-group mt-2">' +
          data.files.map(f => {
            // File type icon
            let ext = f.original_filename.split('.').pop().toLowerCase();
            let icon = '<i class="bi bi-file-earmark"></i>';
            if (ext === 'pdf') icon = '<i class="bi bi-file-earmark-pdf text-danger"></i>';
            else if (ext === 'doc' || ext === 'docx') icon = '<i class="bi bi-file-earmark-word text-primary"></i>';
            else if (ext === 'txt') icon = '<i class="bi bi-file-earmark-text text-secondary"></i>';
            return `
              <li class='list-group-item d-flex justify-content-between align-items-center'>
                <span>${icon} <a href='/static/${f.file_path}' target='_blank'>${f.original_filename}</a></span>
                <span class='text-muted' style='font-size:0.9em;'>${new Date(f.uploaded_at).toLocaleString()}</span>
                <button class='btn btn-sm btn-outline-danger ms-2' onclick='deleteUploadedFile(${f.id})' title='Delete'><i class="bi bi-trash"></i></button>
              </li>
            `;
          }).join('') + '</ul>';
      } else {
        uploadedFilesList.innerHTML = '';
      }
    } catch (err) {
      uploadedFilesList.innerHTML = '';
    }
  }

  // Add delete function to window for global access
  window.deleteUploadedFile = async function(fileId) {
    if (!confirm('Are you sure you want to delete this file?')) return;
    try {
      const response = await fetch(`/api/exam/${examId}/delete-answer/${fileId}`, {
        method: 'DELETE'
      });
      const data = await response.json();
      if (data.success) {
        await loadUploadedFiles();
        fileUploadStatus.innerHTML = '';
      } else {
        alert(data.error || 'Failed to delete file');
      }
    } catch (err) {
      alert('Error deleting file');
    }
  }

  if (uploadAnswerBtn) {
    uploadAnswerBtn.addEventListener('click', async function() {
      const file = answerFileInput.files[0];
      if (!file) {
        fileUploadStatus.innerHTML = '<span class="text-danger">Please select a file to upload.</span>';
        return;
      }
      uploadAnswerBtn.disabled = true;
      fileUploadStatus.innerHTML = 'Uploading...';
      const formData = new FormData();
      formData.append('file', file);
      try {
        const response = await fetch(`/api/exam/${examId}/upload-answer`, {
          method: 'POST',
          body: formData
        });
        const data = await response.json();
        if (data.success) {
          fileUploadStatus.innerHTML = '<span class="text-success">' + data.message + '</span>';
          await loadUploadedFiles();
        } else {
          fileUploadStatus.innerHTML = '<span class="text-danger">' + (data.error || 'Upload failed') + '</span>';
        }
      } catch (err) {
        fileUploadStatus.innerHTML = '<span class="text-danger">Error uploading file.</span>';
      }
      uploadAnswerBtn.disabled = false;
    });
  }

  // Load uploaded files on page load
  loadUploadedFiles();

  // Initialize exam
  async function initializeExam() {
      try {
          // Start exam session
          const response = await fetch(`/api/exam/${examId}/start`, {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json'
              }
          });
          
          const data = await response.json();
          
          if (response.ok) {
              sessionId = data.session_id;
              examStartTime = new Date();
              // Set examEndTime to the lesser of (now + duration) and globalExamEndTime
              const durationEnd = new Date(examStartTime.getTime() + examDuration * 60000);
              examEndTime = durationEnd < globalExamEndTime ? durationEnd : globalExamEndTime;
              startTimeElement.textContent = examStartTime.toLocaleTimeString();
              
              // Load question paper
              await loadQuestionPaper();
              
              // Start proctoring
              startProctoring();
              
              // Start timer
              startTimer();
              
              // Auto-save every 30 seconds
              setInterval(autoSaveAnswer, 30000);
              
              if (endExamBtn) endExamBtn.style.display = '';
          } else {
              // Show a user-friendly message if the exam was already attempted
              if (data.error && data.error.includes('already attempted this exam')) {
                  questionPaperElement.innerHTML = `<div class='alert alert-danger'>You have already attempted this exam and cannot restart it.<br>You will be redirected to the dashboard.</div>`;
                  setTimeout(() => { window.location.href = '/dashboard'; }, 3500);
                  return;
              }
              alert('Error starting exam: ' + data.error);
              window.location.href = '/dashboard';
          }
      } catch (error) {
          console.error('Error initializing exam:', error);
          alert('Error starting exam. Please try again.');
          window.location.href = '/dashboard';
      }
  }

  async function loadQuestionPaper() {
      try {
          const response = await fetch(`/api/exam/${examId}/question-paper`);
          const data = await response.json();
          
          if (response.ok) {
              questionPaperElement.innerHTML = `
                  <div style="white-space: pre-wrap; font-family: 'Courier New', monospace;">
                      ${data.question_paper}
                  </div>
              `;
          } else {
              questionPaperElement.innerHTML = `
                  <div class="alert alert-danger">
                      Error loading question paper: ${data.error}
                  </div>
              `;
          }
      } catch (error) {
          console.error('Error loading question paper:', error);
          questionPaperElement.innerHTML = `
              <div class="alert alert-danger">
                  Error loading question paper. Please refresh the page.
              </div>
          `;
      }
  }

  function startTimer() {
      timerInterval = setInterval(() => {
          const now = new Date();
          const timeLeft = examEndTime - now;
          
          if (timeLeft <= 0) {
              clearInterval(timerInterval);
              timerElement.textContent = 'Time Expired';
              timerElement.className = 'badge bg-danger me-2';
              endExam();
          } else {
              const minutes = Math.floor(timeLeft / 60000);
              const seconds = Math.floor((timeLeft % 60000) / 1000);
              timerElement.textContent = `Time Remaining: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
              
              // Warning when less than 5 minutes left
              if (timeLeft < 300000) { // 5 minutes
                  timerElement.className = 'badge bg-warning me-2';
              }
          }
      }, 1000);
  }

  async function saveAnswer() {
      const answerText = answerTextElement.value.trim();
      // Check if either text or at least one uploaded file exists
      let hasFile = false;
      try {
        const resp = await fetch(`/api/exam/${examId}/my-answers`);
        const data = await resp.json();
        hasFile = data.files && data.files.length > 0;
      } catch {}
      if (!answerText && !hasFile) {
          answerStatusElement.innerHTML = '<div class="alert alert-warning">Please enter an answer or upload an answer script before saving.</div>';
          return;
      }
      if (answerText) {
        try {
            const response = await fetch(`/api/exam/${examId}/submit-answer`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ answer_text: answerText })
            });
            const data = await response.json();
            if (response.ok) {
                answerStatusElement.innerHTML = '<div class="alert alert-success">Answer saved successfully!</div>';
                setTimeout(() => {
                    answerStatusElement.innerHTML = '';
                }, 3000);
            } else {
                answerStatusElement.innerHTML = `<div class="alert alert-danger">Error saving answer: ${data.error}</div>`;
            }
        } catch (error) {
            console.error('Error saving answer:', error);
            answerStatusElement.innerHTML = '<div class="alert alert-danger">Error saving answer. Please try again.</div>';
        }
      } else {
        // Only file uploaded, show success
        answerStatusElement.innerHTML = '<div class="alert alert-success">Answer script uploaded successfully!</div>';
        setTimeout(() => {
            answerStatusElement.innerHTML = '';
        }, 3000);
      }
  }

  async function autoSaveAnswer() {
      const answerText = answerTextElement.value.trim();
      if (answerText) {
          await saveAnswer();
      }
  }

  async function startProctoring() {
      try {
          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
              proctoringStream = await navigator.mediaDevices.getUserMedia({ video: true });
              proctoringVideo.srcObject = proctoringStream;
              
              // Start proctoring analysis
              proctoringInterval = setInterval(async () => {
                  proctoringCanvas.getContext('2d').drawImage(proctoringVideo, 0, 0, proctoringCanvas.width, proctoringCanvas.height);
                  const dataUrl = proctoringCanvas.toDataURL('image/jpeg');
                  const base64 = dataUrl.split(',')[1];
                  
                  try {
                      const response = await fetch('/api/proctoring/analyze', {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({ image: base64 })
                      });
                      
                      const status = await response.json();
                      
                      // Update proctoring status
                      document.getElementById('proctoringFaces').textContent = status.num_faces;
                      document.getElementById('proctoringHeadPose').textContent = status.head_pose;
                      document.getElementById('proctoringLeftEye').textContent = status.left_eye_dir;
                      document.getElementById('proctoringRightEye').textContent = status.right_eye_dir;
                      
                      if (status.left_eye_img) {
                          document.getElementById('proctoringLeftEyeImg').src = `data:image/jpeg;base64,${status.left_eye_img}`;
                      }
                      if (status.right_eye_img) {
                          document.getElementById('proctoringRightEyeImg').src = `data:image/jpeg;base64,${status.right_eye_img}`;
                      }
                      
                      // Check for anomalies
                      checkProctoringAnomalies(status);
                      
                  } catch (err) {
                      console.error('Proctoring analysis error:', err);
                  }
              }, 2000); // Check every 2 seconds
          }
      } catch (error) {
          console.error('Error starting proctoring:', error);
          document.getElementById('proctoringAlerts').innerHTML = `
              <div class="alert alert-warning">
                  Could not access camera for proctoring. Please ensure camera permissions are granted.
              </div>
          `;
      }
  }

  function checkProctoringAnomalies(status) {
      const alertsElement = document.getElementById('proctoringAlerts');
      let alerts = [];
      
      if (status.num_faces === 0) {
          alerts.push('No face detected');
      } else if (status.num_faces > 1) {
          alerts.push('Multiple faces detected');
      }
      
      if (status.head_pose !== 'Center') {
          alerts.push(`Head turned ${status.head_pose.toLowerCase()}`);
      }
      
      if (status.left_eye_dir !== 'Center' && status.left_eye_dir !== 'N/A') {
          alerts.push(`Left eye looking ${status.left_eye_dir.toLowerCase()}`);
      }
      
      if (status.right_eye_dir !== 'Center' && status.right_eye_dir !== 'N/A') {
          alerts.push(`Right eye looking ${status.right_eye_dir.toLowerCase()}`);
      }
      
      if (alerts.length > 0) {
          alertsElement.innerHTML = `
              <div class="alert alert-warning">
                  <strong>Proctoring Alerts:</strong><br>
                  ${alerts.join('<br>')}
              </div>
          `;
      } else {
          alertsElement.innerHTML = '';
      }
  }

  async function endExam() {
      try {
          // Save current answer
          await saveAnswer();
          
          // End exam session
          const response = await fetch(`/api/exam/${examId}/end`, {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json'
              }
          });
          
          const data = await response.json();
          
          if (response.ok) {
              alert('Exam ended successfully!');
              window.location.href = '/dashboard';
          } else {
              alert('Error ending exam: ' + data.error);
          }
      } catch (error) {
          console.error('Error ending exam:', error);
          alert('Error ending exam. Please try again.');
      }
  }

  function stopProctoring() {
      if (proctoringStream) {
          proctoringStream.getTracks().forEach(track => track.stop());
          proctoringStream = null;
      }
      if (proctoringInterval) {
          clearInterval(proctoringInterval);
          proctoringInterval = null;
      }
  }

  // Event listeners
  saveAnswerBtn.addEventListener('click', saveAnswer);
  submitAnswerBtn.addEventListener('click', async function() {
    if (!confirm('Are you sure you want to submit your answer? You will not be able to edit or upload after this.')) return;
    await saveAnswer();
    // Disable all answer inputs and buttons
    answerTextElement.disabled = true;
    answerFileInput.disabled = true;
    uploadAnswerBtn.disabled = true;
    saveAnswerBtn.disabled = true;
    submitAnswerBtn.disabled = true;
    // Disable all delete buttons for uploaded files
    const deleteBtns = uploadedFilesList.querySelectorAll('button[onclick^="deleteUploadedFile"]');
    deleteBtns.forEach(btn => btn.disabled = true);
  });

  endExamBtn.addEventListener('click', () => {
      new bootstrap.Modal(document.getElementById('endExamModal')).show();
  });

  document.getElementById('confirmEndExamBtn').addEventListener('click', () => {
      bootstrap.Modal.getInstance(document.getElementById('endExamModal')).hide();
      endExam();
  });

  // Handle page unload
  window.addEventListener('beforeunload', (e) => {
      if (sessionId) {
          e.preventDefault();
          e.returnValue = 'Are you sure you want to leave? Your exam session will be ended.';
          return e.returnValue;
      }
  });

  // After DOMContentLoaded or in initializeExam, convert end time string to local time for display
  const examEndElem = document.getElementById('examEndTime');
  if (examEndElem) {
      const utcString = examEndElem.getAttribute('data-utc');
      const localDate = new Date(utcString);
      examEndElem.textContent = localDate.toLocaleString();
  }
});
</script>
{% endblock %} 